---
title: "Parameters estimation for calibration"
author: "Simon Jean"
date: "2023-05-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
library(tidyverse)
library(here)
```

# I. Demand estimation
## A. Preliminary analysis : descriptive stats

```{r load data, echo = F}
dat_p = read.csv(here("data","andrew","dat_p.csv")) #Price-quantity data (OG Paper)
dat_b = read.csv(here('data', 'andrew', "dat_bc.csv"))
```

First, look at the evolution of average weight per year : 
```{r avg weight, echo = F}
dat_p %>% 
  group_by(year) %>%
 summarise_at(vars(kg), list(name = mean))%>%
  ggplot(aes(x = year,  y = name))+
  geom_point()+
  theme_bw()+
  ylab('Avg weight')
```

Observe a decrease of average weight. Second, look at the evolution of price per buche through time. To do so, I compute the product of `p` and `g` (price/gram * grams of buche).

```{r pressure, echo=FALSE}
dat_p = dat_p %>%
  mutate(price_buche = g*p,
         price_kg = p*1000)
dat_p %>%
  ggplot(aes(x=year))+
  geom_point(aes(y = price_buche))+
  theme_bw()
```

1. Variance of prices decreases with time
2. Average decreases

Conclusion : it seems like the market has evolved. It is hard to say whether (i) there was a crackdown a decrease in demand or (ii) supply increased. 

That goes along with what follows : the catch has increased for years we have data for : 
```{r}
dat_b %>% subset(y>2013)%>%
  ggplot(aes(x=y, y= c))+
  geom_point(size = 2)+
  theme_bw()+
  ylab("Wet catch in metric tons")+
  xlab('Year')
```
Assuming a constant demand, we can leverage that change in supply to estimate the demand function. 

## B. Data reformating
First, recover individual totoaba poached from dried buche data. To do so: 

1. `q` in `dat_p` is dried totoaba buche in tonnes : q*1000 is tonnes of dried totoaba buche
2. Given that we assume uniform distribution of totoaba size and that 1 totoaba = 500g of dried totoaba dried totoaba in kilos / 0.5 kilos -> Number of totoaba
3. Compare that to catch data :

+ In `dat_p`, take `c` catch data in metric tonnes and convert to kilos (`c*1000`)
+ Under the assumption of uniform distribution of size of caught totoaba, all weigh  25.7 kg (divide catch in kilos by average weight)
```{r, echo =F}
dat_p = dat_p %>% mutate(totoaba = (q*1000)/.5)
dat_b = dat_b %>% mutate(totoaba = (c*1000/25.7))

data.frame( totoaba_est = dat_p %>% select(totoaba) %>% unique() %>% pull(),
            totoaba_obs = dat_b %>% subset(y>2013) %>% select(totoaba)%>%pull(),
            year = c(2014, 2015, 2016, 2017))%>%
  ggplot(aes(x=year))+
  geom_line(aes(y = totoaba_est, colour= 'Recovered from dat_p'), linewidth = 1.1)+
  geom_line(aes(y = totoaba_obs, colour = 'Observed catch'), linewidth = 1.1)
  
```

There is a big difference between estimates! Maybe it makes more sense to use price data per buche and observed catch. 

### C. Attempt 1 : use price per totoaba and variation in realized catch


In what follows : 

* I use the variations in price per totoaba calculated as `price_per_totoaba = p*g` from `dat_p`. 

* I use the variations in realized catch from `dat_bc`, converted to totoaba individuals assuming uniform weight distribution (`tototaba = c*1000/25.7`)

```{r}
results = data.frame()
new_dat = merge(dat_b %>% subset(y>2013) %>% select(y,totoaba) %>%rename(year=y), dat_p %>% select(year, price_buche))
model = lm(price_buche ~ totoaba, data = new_dat)
summary(model)

demand = function(totoaba){
  y = model$coefficients[1] + model$coefficients[2]*totoaba
  return(y)
}

data.frame(x = seq(1,max(dat_b %>% subset(y>2013)%>%select(totoaba)))) %>%
  mutate(demand = demand(x))%>%
  ggplot(aes(x = x, y = demand))+
  geom_line()+
  xlab('Number of totoabas caught (unitless)')+
  ylab('Price (2019 $USD)')+
  theme_bw()

results = results %>% rbind(model$coefficients)
```

### D. Attempt 2 : Use price per totoaba and variation in estimated catch (converting dried buche tons to live totoaba)

Just to make sure we have results that are not too weird, I regress price on estimated catch. 


```{r}
new_dat = dat_p %>% select(price_buche, totoaba)
model = lm(price_buche ~ totoaba, data = new_dat)
summary(model)

demand = function(totoaba){
  y = model$coefficients[1] + model$coefficients[2]*totoaba
  return(y)
}

data.frame(x = seq(1,max(dat_b %>% subset(y>2013)%>%select(totoaba)))) %>%
  mutate(demand = demand(x))%>%
  ggplot(aes(x = x, y = demand))+
  geom_line()+
  xlab('Number of totoabas caught (unitless)')+
  ylab('Price (2019 $USD)')+
  theme_bw()+
  geom_hline(yintercept=0)

results = results %>% rbind(model$coefficients)
```

In the end, we get two demand models : 
```{r}
colnames(results) = c('Intercept (alpha)', 'beta')
print(results)
```

We keep the first model as it seem"s more pertinent. 
```{r}
results = results[1,]
```

# II. Cost data
## A. Poacher cost data
From this section : need to get `W`, the cost parameters of the profit functions. We assume that the measure of effort is the number of trips per year.
```{r}
df_wild = read.csv(here('data', 'w_par.csv'))
W = 8215
c = 68
results = results %>% cbind(W,c)
print(results)
```

## B. Farming cost

```{r}
df_farm = read.csv(here("data", "aqua_par_farm.csv"))
df_farm = df_farm %>%
  mutate(cost_per_toto = Cost_feed_kgyear/Number_Individuals)
df_farm %>% ggplot(aes(x=Totoaba_Age))+
  geom_point(aes(y=cost_per_toto, colour = 'Cost'))
```

# III. Fish parameters

Julia has set up the growth and catchability parameters
```{r}

r = 0.039
k = 20226 # in metric tons of biomass from INAPESCA
k_ = k*1000/25.7

catchability = # in vessel trips ^-1


results = results %>% cbind(r, k_, catchability)
```

# IV. Estimating W

From Julia's calculation, we have average cost. Now the procedure is to find the $W$ parameter that minimizes the difference between a straight cost and a quadratic cost. 

```{r}


# Define coefficients for average costs in different estimation scenarios
avg_cost = 8215.34
min_cost = 3992.27
max_cost = 13327.92

# Define the number of trips as a continuous variable that ranges from 0 to realized trips majored by 50%
values_W = data.frame()

for (x in c(1, 1.2, 1.5)){
  trips = seq(0,1920*x,0.1)

# Define total costs based on different estimation scenarios
  cost_avg = avg_cost * trips
  cost_min = min_cost * trips
  cost_max = max_cost * trips

# Define trips^2
  trips_2 = trips^2

# Define quadratic cost function as a function of the coefficient W
  quadratic_cost = function(W){
    return(W*trips_2)
  }

# Approach 0 : get average cost and divide by average x
  W_avg_trip = avg_cost/(max(trips)/2)
  Ws = c(W_avg_trip = W_avg_trip)
# Approach 1: minimize sum of pointwise squared differences
  difference = function(W)(sum((cost_avg - W*trips_2)^2))


  res = optimize(difference, interval = c(0,1000))

  costs_estimation = data.frame(trips, 
                                cost_avg,
                                quad_cost_avg = quadratic_cost(W),
                                quad_cost_optim = quadratic_cost(res$minimum))
  Ws = append(Ws, c(W_pointwise = res$minimum))

# Second approach : minimize the sum of squared integral difference
  difference = function(W){
    y1 = W*trips_2
    return( (sum(y1) - sum(cost_avg))^2)
  }

  res = optimize(difference, interval = c(0,1000))

  Ws = append(Ws, c(W_integral = res$minimum))
  costs_estimation = costs_estimation%>%
    mutate(quad_cost_optim2 = quadratic_cost(res$minimum))
  
# Third approahc : find W such that the cost for realized trips (1920) is equal for both specifications
  W_exact = avg_cost/1920

  Ws = append(Ws, c(W_exact_1920 = W_exact))
  Ws = append(Ws, x=x, 1)
  costs_estimation = costs_estimation%>%
    mutate(quad_cost_exact = quadratic_cost(W_exact))
  values_W = rbind(values_W, Ws)
}

# Graph : 

costs_estimation%>%
  ggplot(aes(x=trips))+
  geom_line(aes(y=cost_avg, colour = 'linear cost'), linewidth = 1.2)+
  geom_line(aes(y = quad_cost_avg, colour = 'With W average of trips'), linewidth = 1.2)+
  geom_line(aes(y = quad_cost_optim, colour = 'Optim by pointwise difference'), linewidth = 1.2)+
  geom_line(aes(y = quad_cost_optim2, colour = 'Optim by integral difference'), linewidth = 1.2)+
  geom_line(aes(y = quad_cost_exact, colour = 'Linear = quadratic at X = 1920'), linewidth = 1.2)+
  geom_vline(xintercept = 1920)+
  theme_bw()

print(Ws)
```



