---
title: "Parameters estimation for calibration"
author: "Simon Jean"
date: "2023-05-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
options(scipen=999)

library(tidyverse)
library("ggsci")
library(here)
library(knitr)
library(stargazer)
```

# I. Demand estimation
## A. Preliminary analysis : descriptive stats

```{r load data, echo = F}
dat_p = read.csv(here("data","andrew","dat_p.csv")) #Price-quantity data (OG Paper)
dat_b = read.csv(here('data', 'andrew', "totoaba_biomass_catch_20230516.csv")) %>% 
  rename(y = X) %>% 
  rename(b = Biomass..Tonnes.) %>% 
  rename(c = Catch..Tonnes.)
```

### i. Average weight through time
First, look at the evolution of average weight per year : 
```{r avg weight, echo = F}
dat_p %>% 
  group_by(year) %>%
 summarise_at(vars(kg), list(name = mean))%>%
  ggplot(aes(x = year,  y = name))+
  geom_point()+
  theme_bw()+
  ylab('Avg weight')
```

Observe a decrease of average weight. Second, look at the evolution of price per buche through time. To do so, I compute the product of `p` and `g` (price/gram * grams of buche).

### ii. Price of buche through time

```{r pressure, echo=FALSE}
dat_p = dat_p %>%
  mutate(price_buche = g*p,
         price_kg = p*1000, 
         price_buche_kg = price_buche*1000)
dat_p %>%
  ggplot(aes(x=year))+
  geom_point(aes(y = price_buche))+
  theme_bw()
```

1. Variance of prices decreases with time
2. Average decreases

Conclusion : it seems like the market has evolved. It is hard to say whether (i) there was a crackdown a decrease in demand or (ii) supply increased. 

### iii. Evolution of catch
That goes along with what follows : the catch has increased for years we have data for : 
```{r}
dat_b %>% subset(y>2013)%>%
  ggplot(aes(x=y, y= c))+
  geom_point(size = 2)+
  theme_bw()+
  ylab("Wet catch in metric tons")+
  xlab('Year')
```
Assuming a constant demand, we can leverage that change in supply to estimate the demand function. 

#### iv. Evolution of price per kilo for all size buche

```{r}
new_dat = merge(dat_b %>% 
                  subset(y>2013) %>% 
                  select(y,c) %>%
                  rename(year=y), 
                dat_p %>% 
                  subset(year > 2013) %>%
                  select(year, price_buche, price_kg))

new_dat = new_dat %>% mutate(c_kg = c*1000)

new_dat2 = merge(dat_b %>% 
                  subset(y>2013) %>% 
                  select(y,c) %>%
                  rename(year=y), 
                 dat_p %>% 
                   group_by(year)%>%
                   summarise_at(vars(price_kg),
                                list(avg_price_kg = mean)))
# Sample restriction to 2016
#
#new_dat2 %>% 
#  ggplot(aes(x = c,
#             y = avg_price_kg, 
#             colour = as.factor(year)))+
#  geom_point(size = 2)+
#  theme_bw

new_dat %>% 
  ggplot(aes(x = c, 
             y = price_kg, 
             colour = as.factor(year))) + 
  geom_point(size = 2)+
  theme_bw()
```

#### v. Evolution of price of largest size buche


```{r}
dat_p %>%
  subset(kg>0.4)%>%
  ggplot(aes(x = year))+
  geom_point(aes(y = price_kg))+
  theme_bw()
```

### B. Data reformating : dried totoaba, wet catch
First, recover individual totoaba poached from dried buche data. To do so: 

1. `q` in `dat_p` is dried totoaba buche in tonnes : q*1000 is tonnes of dried totoaba buche
2. Given that we assume uniform distribution of totoaba size and that 1 totoaba = 500g of dried totoaba, then dried totoaba in kilos (converted to wet)/ 0.5 kilos -> Number of totoaba
3. Compare that to catch data :

+ In `dat_p`, take `c` catch data in metric tonnes and convert to kilos (`c*1000`)
+ Under the assumption of uniform distribution of size of caught totoaba, all weigh  25.7 kg (divide catch in kilos by average weight)
```{r, echo =F}
#JML. Added a conversion factor that transforms dry weight to wet weight (dw / 0.31 = ww)
# Buche to dry buche conversion has a conversion factor of 0.31; wet weight whole fish to wet buche has a conversion factor of 0.0161
dat_p = dat_p %>% mutate(totoaba = ((q*1000)/0.31)/.5) 

dat_b = dat_b %>% mutate(totoaba = (c*1000/25.7)) 

data.frame( totoaba_est = dat_p %>% select(totoaba) %>% unique() %>% pull(),
            totoaba_obs = dat_b %>% subset(y>2013) %>% select(totoaba)%>%pull(),
            year = c(2014, 2015, 2016, 2017))%>%
  ggplot(aes(x=year))+
  geom_line(aes(y = totoaba_est, colour= 'Recovered from dat_p'), linewidth = 1.1)+
  geom_line(aes(y = totoaba_obs, colour = 'Observed catch'), linewidth = 1.1)
  
```

There is a big difference between estimates! Maybe it makes more sense to use price data per buche and observed catch. 

### C. Graphical analysis of catch and biomass

```{r}
scale = 10
dat_b %>% 
  ggplot(aes(x=y))+
  geom_line(aes(y = c, color = 'Catch (metric tons)'), linewidth = 1.1)+
  geom_line(aes(y = b/scale, color = 'Biomass (metric tons)'), linewidth = 1.1)+
  scale_y_continuous(sec.axis = sec_axis(~.*scale, name='Biomass (metric tons)'))+
  geom_vline(xintercept = 1976, color = 'grey', linewidth = 1, linetype ='dashed')+
  geom_vline(xintercept = 2010, color = 'grey', linewidth = 1, linetype ='dashed')+
  scale_color_aaas()+
  theme_bw()+
  ylab('Catch in tons of biomass')+
  xlab('year')
```

### D. Attempt 1 : use price per totoaba and variation in realized catch


In what follows : 

* I use the variations in price per totoaba calculated as `price_per_totoaba = p*g` from `dat_p`. 

* I use the variations in realized catch from `dat_bc`, converted to totoaba individuals assuming uniform weight distribution (`tototaba = c*1000/25.7`)

```{r}
calibration = data.frame()

new_dat = merge(dat_b %>% 
                  subset(y>2013) %>% 
                  select(y,totoaba) %>%
                  rename(year=y), 
                dat_p %>% 
                  select(year, price_buche, price_kg))

model = lm(price_buche ~ totoaba, data = new_dat)
summary(model)

demand = function(totoaba){
  y = model$coefficients[1] + model$coefficients[2]*totoaba
  return(y)
}

data.frame(x = seq(1,max(dat_b %>% subset(y>2013)%>%select(totoaba)))) %>%
  mutate(demand = demand(x))%>%
  ggplot(aes(x = x, y = demand))+
  geom_line()+
  xlab('Number of totoabas caught (unitless)')+
  ylab('Price (2019 $USD)')+
  theme_bw()
```

But several problems  :
* Upward sloping demand function

### D. Attempt 2 : Use price per totoaba and variation in estimated catch (converting dried buche tons to live totoaba)

Just to make sure we have results that are not too weird, I regress price on estimated catch. 


```{r}
new_dat = merge(dat_b %>% 
                  subset(y>2013) %>% 
                  select(y,
                         c,
                         totoaba) %>%
                  rename(year=y), 
                dat_p %>% 
                  select(year, 
                         price_buche, 
                         price_kg))
model = lm(price_buche ~ totoaba, data = new_dat)
summary(model)

demand = function(totoaba){
  y = model$coefficients[1] + model$coefficients[2]*totoaba
  return(y)
}

data.frame(x = seq(1,max(dat_b %>% subset(y>2013)%>%select(totoaba)))) %>%
  mutate(demand = demand(x))%>%
  ggplot(aes(x = x, y = demand))+
  geom_line()+
  xlab('Number of totoabas caught (unitless)')+
  ylab('Price (2019 $USD)')+
  theme_bw()+
  geom_hline(yintercept=0)

```

### E. Re-estimating demand in biomass units, and with the same pooled OLS method

We want an estimate that relates prices to quantities of biomass. Without any worry of conversion, I regress prices on caught biomass measured in *metric tons*. This model assumes no lag between poaching and selling.

$$
\text{price buche}_{i} = \alpha + \beta \times catch_{i}
$$


The previous cut in time no longer seems to work. Let's use the full sample.

```{r}
new_dat = new_dat %>%
  mutate(price_ton = price_kg * 1000)

new_dat %>%
  ggplot(aes(x = c,
             y = price_ton))+
  geom_point()

model  = lm(price_ton ~ c, data = new_dat)
model2 = lm(price_kg ~c, data = new_dat)
demand = function(biomass){
  y = model$coefficients[1] + model$coefficients[2]*biomass
  return(y)
}

data.frame(x = seq(1,max(new_dat %>%select(c)))) %>%
  mutate(demand = demand(x))%>%
  ggplot(aes(x = x, y = demand))+
  geom_line()+
  xlab('biomass of totoaba (metric tons)')+
  ylab('Price (2019 $USD)')+
  theme_bw()

summary(model)

params = c('alpha', 'beta')
value = c(model$coefficients[1], - model$coefficients[2])
concept = c('Demand model : intercept', 'Demand model : coefficient')
units = c('USD', 'USD/metric ton of biomass')

price_obs = model$coefficients[1] + model$coefficients[2]*307
price_obs = price_obs/1000
```

With this model, typically, observed catch in 2017 yields a price of `r price_obs` \$ USD per kilo of buche. In this case, the value of a 25.7 kilos totoaba is `r .5*price_obs` \$

**Check what happens if we use the recovered values**

### F. Getting the units right

Previous demand estimation related price of buche to biomass of totoaba. However, this is not what we need to do. We need to have price of totoaba and biomass of totoaba. To do so, I'll convert all price data based on the following conversion : $1 \text{kg of totoaba} = 0.019 \text{kg of buche}$. Therefore : 

```{r}
new_dat = new_dat %>%
  mutate(price_ton_toto = price_ton * 0.019)


model  = lm(price_ton_toto ~ c, data = new_dat)
demand = function(biomass){
  y = model$coefficients[1] + model$coefficients[2]*biomass
  return(y)
}

data.frame(x = seq(1,max(new_dat %>%select(c)))) %>%
  mutate(demand = demand(x))%>%
  ggplot(aes(x = x, y = demand))+
  geom_line()+
  xlab('biomass of totoaba (metric tons)')+
  ylab('Price (2019 $USD)')+
  theme_bw()

summary(model)

params = c('alpha', 'beta')
value = c(model$coefficients[1], - model$coefficients[2])
concept = c('Demand model : intercept', 'Demand model : coefficient')
units = c('USD', 'USD/metric ton of biomass')


catch = dat_b %>%
  subset(y ==2017)%>%
  select(c)%>%
  pull()

price_obs = model$coefficients[1] + model$coefficients[2]*catch
price_obs = price_obs/1000
```

With this model, typically, observed catch in 2017 yields a price of `r price_obs` \$ USD per kilo of totoaba. In this case, the value of a 25.7 kilos totoaba is `r 25.7*price_obs` \$, and therefore the kilo of buche sells at `r 25.7*2*price_obs` \$.


# II. Fish parameters

Julia has set up the growth and catchability parameters
```{r}

r = 0.2012827
k = 20226 # in metric tons of biomass from INAPESCA
k_ = k*1000 # in kilos

catchability = 0.0005526788*25.7/1000# in vessel trips ^-1

params = append(params, c('r', 'k','sigma'))
value = append(value, c(r, k, catchability))
concept = append(concept, c('intrinsic growth rate', 'carrying capacity', 'catchability'))
units = append(units, c('unitless', 'metric tons of biomass', '% of biomass/vessel trips'))

```

# III. Estimating costs parameters

## A. Estimating cost parameter $W$

From Julia's calculation, we have average cost. Now the procedure is to find the $W$ parameter that minimizes the difference between a straight cost and a quadratic cost. 

```{r}
dat_w = read.csv(here("data", "w_par.csv"))
max_E = sum(dat_w$total_fleet_days_year)
catchability = dat_b %>% 
  subset(y==2016) %>% 
  select(c)/(max_E *dat_b %>% subset(y==2016) %>% select(b))
catchability = pull(catchability)
```

```{r}

# Define coefficients for average costs in different estimation scenarios
avg_cost = 8215.34 # This is average cost per trip
min_cost = 3992.27 # This is the minimum cost per trip (low season)
max_cost = 13327.92 # This is the maximum cost per trip (high season)

# Define the number of trips as a continuous variable that ranges from 0 to realized trips majored by 50%
values_W = data.frame()

for (x in c(1, 1.2, 1.5)){
  
  trips = seq(0,1920*x,0.1)

# Define total costs based on different estimation scenarios
  cost_avg = avg_cost * trips
  cost_min = min_cost * trips
  cost_max = max_cost * trips

# Define trips^2
  trips_2 = trips^2

# Define quadratic cost function as a function of the coefficient W
  quadratic_cost = function(W){
    return(W*trips_2)
  }

# Approach 0 : get average cost and divide by average x
  W_avg_trip = avg_cost/(max(trips)/2)
  Ws = c(W_avg_trip = W_avg_trip)
# Approach 1: minimize sum of pointwise squared differences
  difference = function(W)(sum((cost_avg - W*trips_2)^2))


  res = optimize(difference, interval = c(0,1000))

  costs_estimation = data.frame(trips, 
                                cost_avg,
                                quad_cost_avg = quadratic_cost(W_avg_trip),
                                quad_cost_optim = quadratic_cost(res$minimum))
  Ws = append(Ws, c(W_pointwise = res$minimum))

# Second approach : minimize the sum of squared integral difference
  difference = function(W){
    y1 = W*trips_2
    return( (sum(y1) - sum(cost_avg))^2)
  }

  res = optimize(difference, interval = c(0,1000))

  Ws = append(Ws, c(W_integral = res$minimum))
  costs_estimation = costs_estimation%>%
    mutate(quad_cost_optim2 = quadratic_cost(res$minimum))
  
# Third approahc : find W such that the cost for realized trips (1920) is equal for both specifications
  W_exact = avg_cost/max_E
  Ws = append(Ws, c(W_exact_1920 = W_exact))
  Ws = append(Ws, x=x, 1)
  costs_estimation = costs_estimation%>%
    mutate(quad_cost_exact = quadratic_cost(W_exact))
  
# Fourth approache : equate marginal costs at existing equilibrium point
  # MC = 2*W*E
  # maxE = 1920
  W_MC_storage = c()
  W_MC = avg_cost/(2*max_E)
  Ws = append(Ws, c(MC_eq = W_MC))
  differ = max_E*avg_cost -W_MC*max_E^2 

  costs_estimation = costs_estimation%>%
    mutate(quad_cost_MC = quadratic_cost(W_MC)+ differ)
  values_W = rbind(values_W, Ws)

}
colnames(values_W) = names(Ws)
W_MC = c(avg_cost/(2*max_E), min_cost/(2*max_E), max_cost/(2*max_E))
# Graph : 

costs_estimation%>%
  ggplot(aes(x=trips))+
  geom_line(aes(y=cost_avg, colour = 'linear cost'), linetype = "dashed")+
  geom_line(aes(y = quad_cost_avg, colour = 'With W average of trips'))+
  geom_line(aes(y = quad_cost_optim, colour = 'Optim by pointwise difference'))+
  geom_line(aes(y = quad_cost_optim2, colour = 'Optim by integral difference'))+
  geom_line(aes(y = quad_cost_exact, colour = 'Linear = quadratic at historical equilibrium'))+
  geom_line(aes(y = quad_cost_MC, colour = 'MC equal at historical equilibrium'))+
  #geom_vline(xintercept = 1920)+
  theme_bw()+
  scale_color_aaas()
print(Ws)


params = append(params, c('W_mid', 'W_low', 'W_high', 'avg_cost'))
value = append(value, c(W_MC, avg_cost))
concept = append(concept, c('Parameter cost such that MC are equal at historical value - middle',
                            'Parameter cost such that MC are equal at historical value - low',
                            'Parameter cost such that MC are equal at historical value - high',
                            'Average cost per vessel trip in data'))
units = append(units, c('USD','USD','USD', "USD"))

```
Several points are worth noting : economic theory should favor the estimate of $W$ such that $MC(E^*)$ is equal for the linear and quadratic cost. This results in a sizeable difference, that can be fixed with a fixed cost parameter. In the end, this would yield the estimate of $W$ to be such that : 
$$
MC(E_{hist}) = 2WE_{hist} = \kappa \Rightarrow W = \frac{\kappa}{2E_{hist}}
$$
The question remains open as to if or how we control for the final difference in costs to assess profitability in equilibrium. I guess this goes to show that the discussion on the computation of profits is still not settled. 

## B. Finding $c$

In this section, I just streamline the code for the parameter and show the variables we use for them. It is worth noting that $c$ so far is only estimated using data from the fishery cost data. It is likely that other costs come into play for transportation, that factor in the risks along the supply chain, and seizures.

```{r}
dat_c = read.csv(here("data","c_par.csv"))

# Convert totoaba to metric tons of biomass
totoaba_ton = dat_c$totoaba_year*25.7/1000

c = dat_c$total_cost/totoaba_ton
```


# V. Simulating the model

### A. Parameters, units of measure

```{r}


# Demand for totoaba buche : USD per unit of biomass of totoaba
alpha = model$coefficients[1]# Choke price in USD 
beta = -model$coefficients[2] # Demand coefficient for 

demand = function(totoaba){
  # Yields price per tons of totoaba
  price = alpha - beta*totoaba
  names(price) = c('price')
  return(price)
}

# Growth function for totoaba biomass (in kilograms)
growth = function(x){
  y = r*x*(1-x/k)
  return(y)
}
# conversion rate of totoaba biomass to buche biomass
conv = .5/25.7

# Catchability
sigma = catchability

# Cost parameters:
W = W_MC[1]

# gamma & v per kilogram of totoaba
dat_aqua = read.csv(here('data', 'aqua_par_farm.csv'))
dat_aqua = dat_aqua %>%
  mutate(cost_per_kilo_toto = Totoaba_Age*2,
         cost_per_ton_toto = cost_per_kilo_toto * 1000,
         cost_per_kilo_buche = cost_per_kilo_toto/conv,
         actual_v = 11293*Totoaba_Age)

gamma_prim = dat_aqua %>% subset(Gamma>0.6 & Gamma < .7) %>% select(Gamma) %>% pull()
age = dat_aqua %>% subset(Gamma>0.6 & Gamma < .7) %>% select(Totoaba_Age) %>% pull()
gamma = gamma_prim*beta
v = dat_aqua %>% subset(Gamma>0.9 & Gamma < 1.1) %>% select(actual_v) %>% pull()

# Cost parameter for monopoly : 
params = append(params, c('age','gamma_prim','gamma', 'v', 'c'))
value = append(value, c(age,gamma_prim, gamma, v, c))
concept = append(concept, c('age of totoaba raised', 'Substitution based on weight', 'Substitutability', 'unit cost of farming', 'unit costs associated with trading'))
units = append(units, c('years', 'unitless', 'unitless', 'USD/ton of biomass', 'USD/ton of biomass'))

```

### B. Check calibration
```{r}
qty_monop = function(x){
 y = (alpha - c)*sigma^2 * x^2 / (2*beta* sigma^2 * x^2 + 2*W)
 return(y)
}

result1 = data.frame( x = seq(1, k))%>%
  mutate(growth = growth(x),
         qty_monop = qty_monop(x),
         differ = growth - qty_monop)

# result1 %>% subset(differ <1 & differ >-1)

ggplot(aes(x=x))+
  geom_line(aes(y = growth))+
  geom_line(aes(y = qty_monop))+
  ylab('Qty : growth / harvest')+
  theme_bw()
#  geom_vline(xintercept =8447*1000)

result1 <- write_csv(result1, here("data","result1.csv"))
```

Now, we need to think. Several things : 

1. Monopoly extraction may be viewed better as in transitory dynamics. Indeed, there is more catch than at a steady state
2. Second, demand estimates may be too small : the maximum harvest in our simulation is a little above 300 tonnes of totoaba a year. However, the recent numbers point to 400 tons.
3. It might be interesting to see, from there, what the simulation yields. It could be interesting to see if the introduction of competition creates different steady states. 

### C. Run prelim analysis : Cournot

```{r}
alpha_w = alpha
alpha_f = alpha
beta_w = beta
beta_f = beta

q_cournot_wild_own = function(x){
  y = ((sigma^2)*(x^2)*(2*beta_f*(alpha_w - c) - gamma*(alpha_f - v)))/(4*beta_f*W + (sigma^2)*(x^2)*(4*beta_f*beta_w - (gamma^2)))
  return(y)
}

s_c_own = function(x){
  y = (2*W*(2*beta_f*(alpha_w - c) - gamma*(alpha_f - v)))/((sigma^2)*(x^2)*(4*beta_f*beta_w - gamma^2) + 4*beta_f*W)
  return(y)
}
q_farmed_cournot = function(s){
  y = (2 * beta_w * (alpha_f - v) - gamma* (alpha_w - (s + c)) )/(4*beta_w*beta_f - gamma^2)
  return(y)
}

result1 = result1 %>% mutate(q_cournot_harvest = q_cournot_wild_own(x),
                             q_cournot_farmed = q_farmed_cournot(s_c_own(x)))

result1 %>%
  ggplot(aes(x = x))+
  geom_line(aes(y = growth, colour = 'Growth'))+
  geom_line(aes(y = qty_monop, colour = 'Monopoly harvest'))+
  geom_line(aes(y = q_cournot_harvest, colour = 'Cournot harvest'))+
  #geom_line(aes(y = q_cournot_farmed, colour = 'Cournot farmed'))+
  theme_bw()+
  ggtitle('Equilibria for Cournot competition compared to monopoly')
```

### D. Run prelim analysis : Bertrand


```{r}
# Parameters
e   = gamma/(beta_w*beta_f - (gamma^2))
a_f = (alpha_f*beta_w - alpha_w*gamma)/(beta_w*beta_f - (gamma^2))
a_w = (alpha_w*beta_f - alpha_f*gamma)/(beta_w*beta_f - (gamma^2))
b_f = beta_f/(beta_w*beta_f - (gamma^2))
b_w = beta_w/(beta_w*beta_f - (gamma^2))

s_b_own = function(x){
  y = (2*W*b_w*( b_f*(2*a_w + e*v) + c*((e^2) - 2*b_f*b_w) + e*a_f))/((sigma^2)*(x^2)*(4*b_f*b_w - (e^2)) + 2*W*b_w*(2*b_w*b_f - (e^2)))
  return(y)
}

q_b_own = function(x){
  y = ((sigma^2)*(x^2)*b_w*(b_f*(2*a_w+e*v) + c*((e^2)- 2*b_f*b_w) + e*a_f))/((sigma^2)*(x^2)*(4*b_w*b_f - (e^2)) + 2*W*b_w*(2*b_f*b_w - (e^2)))
  return(y)
}

quantity_farmed = function(s){
  y = b_f *(2*b_w*a_f + v*(e^2 - 2*b_w*b_f) + e*(a_w + (s+c)*b_w))/(4*b_f*b_w - e^2)
  return(y)
}

result1 = result1 %>% mutate(q_bertrand_harvest = q_b_own(x),
                             q_bertrand_farmed = quantity_farmed(s_b_own(x)))

result1 %>%
  ggplot(aes(x = x))+
  geom_line(aes(y = qty_monop, colour = 'Monopoly harvest'))+
  geom_line(aes(y = growth, colour = 'Growth'))+
  geom_line(aes(y = q_bertrand_harvest, colour = 'Betrand harvest'))+
  geom_line(aes(y = q_bertrand_farmed, colour = 'Bertrand farmed'))+
  theme_bw()
```

## E. Parse all

```{r}
result1 = result1 %>% mutate(ss_monop = growth - qty_monop,
                               ss_cournot = growth - q_cournot_harvest,
                               ss_bertrand = growth - q_bertrand_harvest)
steady_states = c()
  
for(variable in c('ss_monop', 'ss_cournot', 'ss_bertrand')){
  ss = which(sign(eval(parse(text = paste0('result1$',variable)))) != lag(sign(eval(parse(text = paste0('result1$', variable))))))
    if(length(ss)==1){
      steady_states = append(steady_states, c(result1[ss, 1], 
                                              NA,
                                              NA))
    }else if(length(ss)==2){
      steady_states = append(steady_states, c(result1[1, ss[1]], 
                                              result1[1, ss[2]],
                                              NA))
    }else if(lenght(ss)==3){
      steady_states = append(steady_states, c(result1[1, ss[1]], 
                                              result1[1, ss[2]],
                                              result1[2, ss[3]]))
    }
  }
print(steady_states)

actual_steady = steady_states[!is.na(steady_states)]

result1 %>%
  ggplot(aes(x=x))+
  geom_line(aes(y = growth, colour = 'Growth'), linewidth = 1)+
  geom_line(aes(y = qty_monop, colour = 'Monopoly'), linewidth = 1)+
  geom_line(aes(y = q_cournot_harvest, colour = 'Cournot'), linewidth = 1)+
  geom_line(aes(y = q_bertrand_harvest, colour = 'Bertrand'), linewidth = 1)+
  theme_bw()+
  ylab('Growth / harvest')+
  scale_color_aaas()+
# Do we know why adding geom_segments to the plot did not work in a loop? Most likely will be three ss though
  geom_segment(x = actual_steady[1], xend = actual_steady[1], y=0, yend=growth(actual_steady[1]), linetype=2)+
  geom_segment(x = actual_steady[2], xend = actual_steady[2], y=0, yend=growth(actual_steady[2]), linetype=2)+
  geom_segment(x = actual_steady[3], xend = actual_steady[3], y=0, yend=growth(actual_steady[3]), linetype=2)
```

Zoomed output (for both this code snippet and the one before, could be good to make a function to analyse the data from sensitivity analysis.) 
```{r}
result1 %>%
  subset(x < 1.5*max(actual_steady))%>%
  ggplot(aes(x=x))+
  geom_line(aes(y = growth, colour = 'Growth'), linewidth = 1)+
  geom_line(aes(y = qty_monop, colour = 'Monopoly'), linewidth = 1)+
  geom_line(aes(y = q_cournot_harvest, colour = 'Cournot'), linewidth = 1)+
  geom_line(aes(y = q_bertrand_harvest, colour = 'Bertrand'), linewidth = 1)+
  # Vertical lines
  geom_segment(x = actual_steady[1], xend = actual_steady[1], y=0, yend=growth(actual_steady[1]), linetype = 2)+
  geom_segment(x = actual_steady[2], xend = actual_steady[2], y=0, yend=growth(actual_steady[2]), linetype = 2)+
  geom_segment(x = actual_steady[3], xend = actual_steady[3], y=0, yend=growth(actual_steady[3]), linetype = 2)+
  # Horizontal lines
  geom_segment(x = 0, xend = actual_steady[1], y=growth(actual_steady[1]), yend=growth(actual_steady[1]), linetype = 2)+
  geom_segment(x = 0, xend = actual_steady[2], y=growth(actual_steady[2]), yend=growth(actual_steady[2]), linetype = 2)+
  geom_segment(x = 0, xend = actual_steady[3], y=growth(actual_steady[3]), yend=growth(actual_steady[3]), linetype = 2)+
  theme_bw()+
  ylab('Growth / harvest')+
  scale_color_aaas()
```

Outputs of the model are: 
```{r}
# Analyse market prices : 

bertrand_ss = steady_states[6:9]

# In case of monopoly : 
dat_monop = result1 %>% subset(x %in% steady_states[4:6]) %>%
  select(qty_monop)%>%
  mutate(p = alpha - beta*qty_monop)
kable(dat_monop)
# In case of cournot :
dat_cournot = result1 %>% subset(x %in% steady_states[4:6])%>%
  select(q_cournot_farmed, q_cournot_harvest)%>%
  mutate(price_paid_to_poacher = s_c_own(x))
kable(dat_cournot)
# In case of Bertrand : 
dat_bertrand = result1 %>% subset(x %in% steady_states[7:9])%>%
  select(q_bertrand_farmed, q_bertrand_harvest)%>%
  mutate(price_paid_to_poacher = s_b_own(x),
         diff_cost = price_paid_to_poacher + c - v)
kable(dat_bertrand)
```


## F. Conclusion from preliminary results : 
 
1. Competition only will not *radically* change the demise of totoaba
2. It may help to reach slightly larger steady state values, but will eventually lead to a drastic depletion of the stock
3. In order to change that dynamic, several interventions would be needed : 
* For example, one could think about different $(\gamma, v)$ pairs
* Or consider the effect of being more competitive at the farming level

4. It is unclear what we can do to go beyond our results with this model. 

# Analysis of new scenarios?

For example, can we think of ways that would curb the exploitation? For example, what about cracking down on demand, or technological research that makes production less costly? Or compare the impact of different cost measures for poaching, at the trader and poacher level? 

# Table for parameters (values, concept and units)

Goal here is to leverage this table to do (i) sensitivity analysis and (ii) to investigate policy scenarios

```{r}
calibration = data.frame(params, value, concept, units)

kable(calibration, caption = 'Parameters used for calibration')

write.csv(calibration, here('data','calibration_params.csv'))
```

Several comments : 

* $\alpha$ and $\beta$ : Demand may need further work. However, the estimates do not look too crazy.
  + However, there must be a conversion problem!!! One can relate the estimation of the price of buche to the catch of totoaba. However, when considering the revenue, the price applies to **the quantity of buche** not to the biomass of totoaba. Need to correct for that. 
  + => Check for conversion : the conversion rate affects the outcome variable, so the coefficients change by the same proportion. Therefore, the cost effect increases slightly but it is not sufficient to bring back to a steady state.
* $r$ looks pretty solid
* $W$s are variable, but make little difference (I have tried with 2 to 10, no difference)
* $\sigma$ did not have much of an impact either
* $\gamma$ has to change and I'll program a loop tomorrow to have all the realistic values : it needs to include the profit function of the farmers, to find which maximizes its profit. There might be some discounting at play here. 
* $v$ can move but unless we pick a shorter rotation, it is more likely to go up if we include operational costs
  + We can have a $v_{net}$ parameter that influences the equilibrium. However, I've ran a couple of tests today, it seems that unless the subsidy is close to a 1,000,000 \$/ton, it does not make a difference.
  + At some point, if profitability is what we aim at tackling, we need to have data on fixed costs and number of pens operating.
* $c$ can move a lot I think. Our estimate is based on fines, and bribes, and convictions on the fishery end. It's a lot, but I'm sure there is an argument to increase it. 

## Sensitivity analysis

The difference between the curves is very small. Several things could be changed from the way we work : 

* $c$ seems too low. For now, $c$ includes only fishery related costs : other costs associated with transports, sanctions and seizures should be factored in. To do so, I'll run a range of values for $c$ ranging from 100% to 500%
* $v$ seems low as well, as it only includes feed costs for aquaculture. I'll run a range of values for $v$ ranging from 100% to 500%
* Our choice of $\gamma$ and $v$ are subject to change. $\gamma$ is difficult to take at face value : it is based on a weight ratio, and does not factor in a differential based on wild v. farmed totoaba. Although the weight may be the same, other quality characteristics such as fat content could play a role. 
In order to manage that, I'll run all the potential values of $\gamma$ and $v$, with adjustment factors for $\gamma$ (from 70% to 100%)
* For $\alpha$, I'll run specifications ranging from 80 to 120% of the value


```{r}
dat_sensititivy = read.csv(here('data', 'sensitivity_steady_states.csv'))
print('Distribution of monopoly steady states')
summary(dat_sensititivy$ss_monop_1)

print('Distribution of Cournot steady states')
summary(dat_sensititivy$ss_cournot_1)

print('Distribution of Betrand steady states')
summary(dat_sensititivy$ss_bertrand_1)
```


# To do

* Verify $r$
* Get profits and quantities as an output of the model, to retro engineer the choice of $\gamma$. Can be a cool side result to check if optimal rotation changes with imperfect competition. 

Plan is therefore : 
* Sunday : 
  + Settle parameters
  + Finish results : check if there are all the desired outputs in the second module I'm prepping for the analysis of steady state results (see file `r sensitivity_analysis.Rmd`, section 'define function to run model').
  + Run sensitivity analysis : it includes various subsidy schemes (see file `r sensitivity_analysis.Rmd`), ranging from 20% to 200% of unit production cost. 
* Monday : 
  + finish writing results the best way possible
  + Finalize calibration, especially data sources
  + Write discussion
  
# Simple figure for paper:

```{r}
qty_monop = function(x){
 y = (400 - 4)*.02^2 * x^2 / (2*80* 0.02^2 * x^2 + 2*5)
 return(y)
}

growth = function(x){
  y = 0.1*x*(1-x/100)
  return(y)
}
  
data.frame(x = seq(1,100))%>%
  mutate(monop = qty_monop(x),
           growth = growth(x))%>%
  ggplot(aes(x = x))+
  geom_line(aes(y = monop, colour = 'Harvest'), linewidth = 1.2)+
  geom_line(aes(y = growth, colour = 'Growth'), linewidth = 1.2)+
  scale_color_manual(values = c( 'grey','black'))+
  ylim(0,2.5)+
  ylab('Quantity')+
  xlab('Stock')+
  theme_classic()+
  geom_segment(x = 8, xend = 8, y = 0, yend= .75, linetype = 2)+
  geom_segment(x = 31, xend = 31, y = 0, yend= 2.1, linetype = 2)+
  geom_segment(x = 61, xend = 61, y = 0, yend= 2.35, linetype = 2)+
  annotate('text', x = 15, y = .7, label= 'stable')+
  annotate('text', x = 25, y = 2.2, label= 'unstable')+
  annotate('text', x = 65, y = 2.45, label= 'stable')+
  theme(legend.position = "none")

```


  