```{r libraries}

library(here)
library(tidyverse)
library(janitor)
library(broom)
library(deSolve)

```

```{r base case parameters}

# Define the parameters for the biological resource
r <- 0.16 #intrinsic rate of population increase, estimated
k <- 100000 #carrying capacity, number of individuals
sigma <- 0.000167 #catchability, ranging from 0.000167 to 0.000256

# Define the parameters for the poaching effort
n <- 0.1
P <- 221 #exogenous market price per unit of output
W <- 5 #cost parameter, range is 2.18 to 7.6, midpoint 5
theta <- 2 #cost parameter, assumed to be 2
z <- 2 * W
s <- 25 #price paid to poachers, ranges from $15-25 

# Initial conditions
initial_x <- 2600 #number of individuals
initial_E <- 0.000104 #presumably catch per unit effort, which is 0.000104 to 0.15 for rhinos

# Time points for the simulation
time_points <- seq(0, 50, 0.1)

```


```{r step 2.1. basic poaching model}

# Calculate the steady-state population (x*)
x_star <- (z * r * k) / (s * sigma^2 * k + z * r)

# Parameter values for the ODE
params <- c(r, k, sigma, n, s, W)

# Define the ODE system for the biological resource and poaching effort
dynamics_ode <- function(t, state, params) {
  x <- state[1]
  E <- state[2]
  
  r <- params[1]
  k <- params[2]
  sigma <- params[3]
  n <- params[4]
  s <- params[5]
  W <- params[6]
  
  # Include the total quantity harvested, q
  q <- sigma * x * E

  dxdt <- r * x * (1 - x / k) - q
  dEdt <- n * (s * sigma * x) - (theta * W * E)

  return(list(c(dxdt, dEdt)))
}

# Solve the ODE
result <- ode(y = c(initial_x, initial_E), times = time_points, func = dynamics_ode, parms = params)

# Convert the result to a data frame
result_df <- as.data.frame(result)
result_df <- cbind(result_df, x_star = x_star)
colnames(result_df) <- c("time", "population", "effort", "x_star")


# Plot the biological resource dynamics and the steady-state population
ggplot(result_df, aes(x = time, y = population)) +
  geom_line(color = "blue") +
  geom_hline(aes(yintercept = x_star), linetype = "dashed", color = "green") +
  labs(title = "Steady State Population, x* (Green)",
       x = "Time",
       y = "Population") +
  theme_minimal()

```

```{r step 2.2. price takers}
# Case One. Traders are monopsonists when it comes to purchasing wildlife commodities from poachers, but sell their outputs elsewhere taking prices as given.

result_df <- result_df %>% rename(x=population)

# Calculate the equilibrium effort (E*) for a given price s
result_df$E_star <- s * sigma * result_df$x / z

# Calculate the equilibrium harvest rate (q_w) for a given price s 
result_df$q_w <- (s * sigma^2 * result_df$x^2) / z

# Calculate the optimal trader-poaching price (s*), produces the same value as P/2
# Define pi_w function
pi_w <- function(s, P, x, z, sigma) {
  q_w <- (s * sigma^2 * x^2) / z
  pi_w_value <- (P * q_w) - (s * q_w)
  return(-pi_w_value) # We return the negative value because we want to maximize pi_w
}
# Optimize pi_w with respect to 's'
result_df <- result_df %>%
  mutate(
    E_star = s * sigma * x / z,
    q_w = (s * sigma^2 * x^2) / z,
    s_star = pmap_dbl(list(P = P, x = x, z = z, sigma = sigma), function(P, x, z, sigma) {
      optim_result <- optim(par = 0.5 * P, fn = pi_w, method = "Brent", lower = 0, upper = P, P = P, x = x, z = z, sigma = sigma)
      return(optim_result$par)
    })
  )

# Calculate the quantity (q_w_p) at optimal trader-poaching price s*
result_df$q_w_p <- (P * sigma^2 * result_df$x^2) / (2 * z)

```

```{r step 3.1 trader as monopolist}

#Parameters for the trader's payoff function
alpha <- 6182 #parameter associated with the inverse demand function
beta <- 2.13 #parameter associated with the inverse demand function
c <- 50 #costs associated with the transportation and final sale of wild animal products 

# Calculate s_m (equilibrium remuneration paid to poachers)
s_m <- function(alpha, c, z, beta, sigma, x) {
  return((z * (alpha - c)) / (2 * beta * sigma^2 * x^2 + z))
}

# Calculate q_m (equilibrium harvest of wild animals when there is no captive breeding program)
q_m <- function(alpha, c, beta, W, sigma, x, z) {
  return(((alpha - c) * sigma^2 * x^2) / (2 * beta * sigma^2 * x^2 + z))
}

# Modify the result_df data frame
result_df <- result_df %>%
  mutate(
    s_m = s_m(alpha, c, z, beta, sigma, x),
    q_m = q_m(alpha, c, beta, W, sigma, x, z)
  )

# Function to find the roots of the equation q_m = r * x * (1 - x / k)
find_roots <- function(q_m_value, r, k) {
  a <- r / k
  b <- -r
  c <- q_m_value
  
  roots <- Re(polyroot(c(a, b, c)))
  sorted_roots <- sort(roots)
  
  return(list(
    low_stable_equilibrium = sorted_roots[1],
    unstable_equilibrium = sorted_roots[2],
    high_stable_equilibrium = sorted_roots[3]
  ))
}

# Calculate the q_m value for the monopolist's optimal harvest
q_m_value <- result_df$q_m[1]

# Find the intersection points
intersection_points <- find_roots(q_m_value, r, k)

# Print the intersection points
print(intersection_points)

# Calculate q_natural_growth for each x value in result_df
result_df <- result_df %>%
  mutate(
    q_natural_growth = r * x * (1 - x / k)
  )

# Calculate intersection points
low_stable_eq <- intersection_points$low_stable_equilibrium
unstable_eq <- intersection_points$unstable_equilibrium
high_stable_eq <- intersection_points$high_stable_equilibrium

# Create the ggplot
ggplot(result_df, aes(x = x)) +
  geom_line(aes(y = q_m), color = "red", linetype = "dashed") +
  geom_line(aes(y = q_natural_growth), color = "blue", linetype = "solid") +
  labs(
    title = "Population vs. Equilibrium Harvest",
    x = "Population (x)",
    y = "Harvest (q_m)"
  ) +
  theme_minimal()

```


